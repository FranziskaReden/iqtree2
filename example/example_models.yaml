#
# example_models.yaml
#


#### definition for DNA data ###
# Note: Data types are not supported: this will be ignored.

- datatype: YDNA
  state: [ A, C, G, T ]
  missing: [ N, "?" ]
  gap: "-"
  equate:
    U: T      # T and U are the same
    R: [A, G] # R is interpreted as A or G
    Y: [C, T]
    W: [A, T]
    S: [G, C]
    M: [A, C]
    K: [G, T]
    B: [C, G, T]
    H: [A, C, T]
    D: [A, G, T]
    V: [A, G, C]

- substitutionmodel: YJC_BIN
  description:    Binary Jukes-Cantor model
  reversible:     true
  datatype:       BIN
  stateFrequency: [ 0.5, 0.5 ]
  rateMatrix:     
  - [ ]
  - [ 1 ]

- substitutionmodel: YGTR_BIN
  description:       General Time Reversible Binary model
  citation:          “Tavare, 1986”
  reversible:        true
  datatype:          BIN
  parameters:
  - name:  r(1..1)             
    type:  rate
    range: [ 0.0001, 100 ]  
    initValue: 1.0 
  - name:  f(1..num_states) # frequency vector f(1), ..., f(4)
    type:  frequency # make parameters in range [0,1] and sum to 1.0
    range: [ 0, 1]
  rateMatrix:
  - [      ,     r(1)*f(2) ]
  - [ r(1)*f(1),           ]
  stateFrequency: estimate

- substitutionmodel: YJC
  description: Jukes-Cantor model
  citation: “Jukes and Cantor, 1969”
  datatype: DNA
  reversible: true
  stateFrequency: [ 0.25, 0.25, 0.25, 0.25 ]
  rateMatrix:
  - [  , 1, 1, 1 ]
  - [ 1,  , 1, 1 ]
  - [ 1, 1,  , 1 ]
  - [ 1, 1, 1,   ]

- substitutionmodel: YJC_ERROR 
  frommodel:  YJC
  description: "YJC with a built-in tip likelihood matrix"
  #errormodel: "+EA" # if not set, defaults to "+E"
  parameters:
    - name:  epsilon
      type:  rate
      range: [ 0.0001, 0.5 ]
      initValue: 0.05

- substitutionmodel: YTIP_EXPLICIT
  frommodel: YJC
  description: "YJC with an explicit tip likelihood matrix"
  parameters:
    - name: tiplikelihood
      type: matrix
      value:
        - [ 0.88, 0.01, 0.10, 0.01 ]
        - [ 0.01, 0.88, 0.01, 0.10 ]
        - [ 0.10, 0.01, 0.88, 0.01 ]
        - [ 0.01, 0.10, 0.01, 0.88 ]

- substitutionmodel: YTIP
  frommodel:         ANY
  description:       " with a formulaic tip likelihood matrix"
  parameters:
    - name:          e
      type:          other
      initValue:     0.05
    - name:          tiplikelihood
      type:          matrix
      rank:          num_states
      formula:       "(row==column) ? (1-e) : (e/(num_states-1))"
  stateFrequency:    estimate

- substitutionmodel: YTIP2
  frommodel:         YJC+YTIP  #tests inheritance from multiple models

- substitutionmodel: YRIGHTASSOC
  frommodel:         YTIP2
  description:       "Right-associativity (constraint) test"
  parameters:
    - name: [a,b,c,d,gamma_shape,categories]
      type: other
      intValue: 0
  constraints:
    - a=b=1
    - categories=2
    - gamma_shape=1.2
    - c=chi2(1.0/categories/2.0, 2.0*gamma_shape)
    - d=chi2(3.0/categories/2.0, 2.0*gamma_shape)

### GTR model ###
- substitutionmodel: YGTR
  description: “General time reversible”
  citation: “Tavare, 1986”
  reversible: true
  datatype: DNA
  parameters:
  - name:  r(1..5)          # rate parameter vector r(1), ... , r(5)
    type:  rate
    range: [ 0.0001, 100 ] 
    initValue: 1.0            
  - name:  f(1..num_states) # frequency vector f(1), ..., f(4)
    type:  frequency        # make parameters in range [0,1] and sum to 1.0
    range: [ 0, 1]
  rateMatrix:
  - [      ,     r(1)*f(2), r(2)*f(3), r(3)*f(4) ]
  - [ r(1)*f(1),          , r(4)*f(3), r(5)*f(4) ]
  - [ r(2)*f(1), r(4)*f(2),          , f(4)      ]
  - [ r(3)*f(1), r(5)*f(2), f(3)     ,           ]
  stateFrequency: estimate

  #not supported yet
- substitutionmodel: COV_GTR
  frommodel:   YGTR
  description: "Covarion model switching between invariant and GTR"
  parameters:
    - name: [ s0, s1 ] #switching rate parameters
      range: [ 0.0001, 100 ]

- substitutionmodel: YCONSTRAINT
  frommodel: YGTR
  description: "Test of addition of constraints"
  constraints:
    - r(1) = 1
    - r(3) = 1

- substitutionmodel: YDAY
  description:       Dayhoff
  url:               https://www.ebi.ac.uk/goldman-srv/dayhoff/dayhoff-dcmut.dat
  citation:          Kosiol,C. and Goldman,N. The Different Versions of the Dayhoff Rate Matrix.
  reversible:        true
  datatype:          AA
  stateOrder:        [ A, R, N, D, C, Q, E, G, H, I, L, K, M, F, P, S, T, W, Y, V ]
  stateName:         [ Ala, Arg, Asn, Asp, Cys, Gln, Glu, Gly, His, Ile, 
                       Leu, Lys, Met, Phe, Pro, Ser, Thr, Trp, Tyr, Val ] 
  parameters:
    - name:          f(1..20)
      description:   state frequency
      type:          frequency
      range:         [0,1]
      initValue:     [ 0.08712691, 0.04090396, 0.04043196, 0.04687195, 0.03347397,
                       0.03825496, 0.04952995, 0.08861191, 0.03361897, 0.03688596,
                       0.08535691, 0.08048092, 0.01475299, 0.03977196, 0.05067995,
                       0.06957693, 0.05854194, 0.01049399, 0.02991597, 0.06471794 ]
    - name:         rateMatrix
      description:
      type:         matrix 
      rank:         num_states
      value:
        - [ ]
        - [ 27 ]
        - [ 98,  32 ]
        - [ 120, 0,   905 ]
        - [ 36,  23,  0,   0 ]
        - [ 89,  246, 103, 134,  0 ]
        - [ 198, 1,   148, 1153, 0,  716 ]
        - [ 240, 9,   139, 125,  11,  28,  81 ]
        - [ 23,  240, 535, 86,   28,  606, 43, 10 ]
        - [ 65,  64,  77,  24,   44,  18,  61, 0,   7 ]
        - [ 41,  15,  34,  0,    0,   73,  11, 7,   44,  257 ]
        - [ 26,  464, 318, 71,   0,   153, 83, 27,  26,  46,  18 ]
        - [ 72,  90,  1,   0,    0,   114, 30, 17,  0,   336, 527, 243 ]
        - [ 18,  14,  14,  0,    0,   0,   0,  15,  48,  196, 157, 0,   92 ]
        - [ 250, 103, 42,  13,   19,  153, 51, 34,  94,  12,  32,  33,  17,  11 ]
        - [ 409, 154, 495, 95,   161, 56,  79, 234, 35,  24,  17,  96,  62,  46,  245 ]
        - [ 371, 26,  229, 66,   16,  53,  34, 30,  22,  192, 33,  136, 104, 13,  78, 550 ]
        - [ 0,   201, 23,  0,    0,   0,   0,  0,   27,  0,   46,  0,   0,   76,  0,  75, 0 ]
        - [ 24,  8,   95,  0,    96,  0,   22, 0,   127, 37,  28,  13,  0,   698, 0,  34, 42,  61 ]
        - [ 208, 24,  15, 18,    49,  35,  37, 54,  44,  889, 175, 10,  258, 12,  48, 30, 157, 0, 28 ]

        #Ideally, we'd declare the above as a matrix, scaledratematrix,
        #and then declare the ratematrix... with an expression.
        # type:         matrix 
        # value:        scaledratematrix/divisor
        #

  stateFrequency:    f

- substitutionmodel: YB18
  frommodel:       YDAY
  reversible:      true
  datatype:        AA
  stateOrder:      [ A, R, N, D, C, Q, E, G, H, I, L, K, M, F, P, S, T, W, Y, V ]
  stateFrequency:  estimate
  parameters:
    - name:        v(1..20)
      description: volume
      type:        rate
      initValue:   [31, 124, 56, 54, 55, 85, 83, 3, 96, 111, 111, 119, 
                    105, 132, 32.5, 32, 61, 170, 136, 84]
    - name:        f(1..20)
      description: state frequency
      type:        frequency
      range:       [0,1]
      initValue:   1/num_states

- substitutionmodel: YCODON
  reversible:        true
  datatype:          CODON
  parameters:
    - name:        f(1..num_states)
      description: state frequency
      type:        frequency
      range:       [0,1]
      initValue:   1/num_states
    - name:        r(1..(num_states*num_states-num_states)/2)
      type:        rate
      range:       [ 0.0001, 100 ]   
      initValue:   1 
    - name:        e
      type:        other
      initValue:   0.05
    - name:        tiplikelihood
      type:        matrix
      rank:        num_states
      formula:     "(row==column) ? (1-e) : (e/(num_states-1))"
    - name:        i
      type:        other
    - name:        rateMatrix
      type:        matrix
      rank:        num_states
      formula:     "i=((column<row) 
                       ? (row-1+(column-1)*(num_states-1)-column*(column-1)/2)
                       : (column-1+(row-1)*(num_states-1)-row*(row-1)/2)), 
                    (row==column) ? 1 : (f(column)* r(i))"

#Rate models can be suffixed with a number 
#(the number of rates). 
#G, H, and R *need* categories to be set, and I does not.



- ratemodel:        G
  ratedistribution: gamma
  #Todo: better handling of models that need categories set.
  #Something like: a list of requirements, each with a rationale.
  requirements:
    - requirement:  0 < categories
      rationale:    Number of categories must be specified 
                    for gamma distribution
  parameters:
  - name:           gamma_shape
    type:           shape
    tolerance:      0.001
  - name:           rate(1..categories)
    type:           calculated rate
    initValue:      gammarate(gamma_shape, subscript)
                    #formerly: "(categories==1) ? 1.0 
                    #  : chi2((2.0*subscript-1)/categories/2.0, 2.0*gamma_shape) / (2.0*gamma_shape))"
                    #but calling gammarate() is much clearer
    tolerance:      0.001
  - name:           proportion(1..categories)
    type:           proportion
    initValue:      1/categories
    tolerance:      0.001

- ratemodel:        H
  ratedistribution: heterotachy
  parameters:
  - name:           proportion(1..categories)
    type:           proportion
    range:          0.0001 .. 1
    initValue:      1/categories
    tolerance:      0.001

- ratemodel:        R
  ratedistribution: free
  optimisation:     2-BFGS,EM
  parameters:
  - name:           proportion(1..categories)
    type:           proportion
    range:          [0.001 .. 1.0] #Even though, RateFree declares MAX_FREE_RATE_PROP 1000
    initValue:      1/categories
    tolerance:      0.001
  - name:           rate(1..categories)
    type:           rate
    range:          [0.001, 1000.0]
    tolerance:      0.001
    initValue:      rand(2.0) #start with random rate values

- ratemodel:        I
  ratedistribution: invariant
  parameters:
  - name:           invariant_proportion
    type:           invariant_proportion
    initValue:      0.1          #Might want to guess at this another way
    tolerance:      0.001

- ratemodel:        K
  ratedistribution: kategory
  parameters:
  - name:           rate(1..categories)
    type:           rate
    range:          [0.001, categories]
    tolerance:      0.001

- ratemodel:        GFOUR   #test that rates and proportions will be recalculated 
                             #when categories is initialized/constrained.
  frommodel:        G
  constraints:
  - categories = 4  

- substitutionmodel:   YMIX
  description:         "Model Mixture of JC and GTR"
  ratemodel:           I+H4
  parameters:
  - name:              w(1..2)
    type:              weight  # type weight implies that w[1]+w[2]=1.0
    range:             [0.01,0.99]
    tolerance:         0.01
  model_mixture:               # mixture components defined in this section
  - substitutionmodel: YMIX_JC
    frommodel:         YJC     # 1st component from JC model
    weight:            w(1)    # weight parameter
    scale:             1.0     # scaling factor of Q matrix for this component
  - substitutionmodel: YMIX_GTR
    frommodel:         YGTR # 2nd component from GTR model
    weight:            w(2)
    scale:             1.0   

#Shared parameters are not supported yet (only... enabled a bit).
#You could already hang parameters on the YMIX
#mixture class, and have things *in* the models, in the model_mixture
#calculated (or initialized) in terms of the parameters on the YMIX class.
#There is *nothing* special about the w (weight) parameter here,
#except that it gets optimized.
#This would *work*, sort of (but the parameters on YMIX would only 
#be read ONCE, at the beginning of model optimization).
#And without vector and matrix assignment, it'd be cumbersome!

#However, IF optimization ran on the parameters, of the parent
#(in this case YMIX), those "linked" parameters *could* be 
#optimized and then "distributed" to the models in the mixture
#(in this case YMIX_JC and YMIX_GTR). 
#But... Wouldn't this be very slow?  
#Here, for example, each iteration would be
#
# Try one tuple of parameter settings on YMIX
#   Optimize YMIX_JC and YMIX_GTR separately
#   Evaluate the (obvious) objective function for YMIX.
#   Choose new settings for YMIX... try again.
#   Check for convergence.  Loop if not converged. 
#

#
# this is an example only; as yet, it won't be parsed at all.
# I'm planning to have divergence graphs passed in via command
# line parameters too.  For that, you'd pass in a Newick 
# format .tree file, which'd be treated as a rooted tree;
# names on interior nodes would be treated as clade names.  
# For any node of degree >3, the "down-clade" nodes are to be 
# arranged into whatever bifurcating tree works best for them.
# But all that is a *long* way off.  First, we need to get FUNDI
# working for *fixed* input trees.  THEN we can worry about
# honouring divergence graphs during initial tree construction,
# maximum parsimony optimisation, and the likelihood hill-climbing
# tree search.
#

#
#this is an example only, as divergent_models not yet parsed
#(as there is, as yet, no YAML wrapper for ModelDivergent). 
#
- substitutionmodel:   DIVERGENT
  description:         "Model for sites with divergence"
  divergent_models:    # mixture components defined in this section
  - substitutionmodel: FISH
    frommodel:         YGTR
    clades:            [ Fish ]
  - substitutionmodel: NONFISH
    frommodel:         YGTR
    #if clades not supplied, on one of the divergent models,
    #it will apply to the remainder of the taxa.

#
# this is an example only, because DIVERGENT will NOT work
# (yet!). 
#
- substitutionmodel:   FUNDI
  parameters:
  - name:              w(1..2)
    type:              weight  # type weight implies that w[1]+w[2]=1.0
    range:             0.01 .. 0.99
    tolerance:         0.01
  model_mixture:               # mixture components defined in this section
  - substitution_model: F_YJC
    frommodel:          YJC     # 1st component from JC model
    weight:             w(1)    # weight parameter
  - substitution_model: F_DIV
    frommodel:          DIVERGENT
    weight:             w(2)

  
#Note: linked_models and tree_mixture are not parsed as yet.
#(tree_mixture isn't even parsed). But they could be.  

- substitutionmodel: YTREEMIX #Tree mixtures are not suported.  Yet.
  frommodel:         YMIX
  description:       "Tree Mixture"
  parameters:
  - name:            treeweight(1..3)
    type:            weight
    range:           0..1            #test that ranges can be supplied in .. format
    initialValue:    [0.5, 0.3, 0.2] #test of assigning vector of inital values
    tolerance:       0.01
  linked_models:
  - substitutionmodel: YJC2
    frommodel:         YJC
  tree_mixture:
  - tree:            A
    weight:          treeweight(1)
    model:           YJC2+I+R{2}
  - tree:            B
    weight:          treeweight(2)
    model:           YJC2+I+R{4}
  - tree:            C
    weight:          treeweight(3)
    model:           YGTR+GAMMA_INVAR{3}
